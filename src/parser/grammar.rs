// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use super::super::{ast, interpret};
use self::RuleResult::{Matched, Failed};
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> { Matched(usize, T), Failed, }
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter)
     -> ::std::result::Result<(), ::std::fmt::Error> {
        try!(write ! (
             fmt , "error at {}:{}: expected " , self . line , self . column
             ));
        if self.expected.len() == 1 {
            try!(write ! (
                 fmt , "`{}`" , escape_default (
                 self . expected . iter (  ) . next (  ) . unwrap (  ) ) ));
        } else {
            let mut iter = self.expected.iter();
            try!(write ! (
                 fmt , "one of `{}`" , escape_default (
                 iter . next (  ) . unwrap (  ) ) ));
            for elem in iter {
                try!(write ! ( fmt , ", `{}`" , escape_default ( elem ) ));
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str { "parse error" }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn slice_eq_case_insensitive(input: &str, state: &mut ParseState, pos: usize,
                             m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() ||
               input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let mut remaining = pos;
    let mut lineno: usize = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
struct ParseState {
    max_err_pos: usize,
    expected: ::std::collections::HashSet<&'static str>,
}
impl ParseState {
    fn new() -> ParseState {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),}
    }
    fn mark_failure(&mut self, pos: usize, expected: &'static str)
     -> RuleResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn parse_parse<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> RuleResult<ast::Block> {
    parse_block(input, state, pos)
}
fn parse_block<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> RuleResult<ast::Block> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res = parse_statement(input, state, pos);
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, repeat_value)
                };
            match seq_res {
                Matched(pos, s) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        match parse_expression(input, state,
                                                               pos) {
                                            Matched(newpos, value) => {
                                                Matched(newpos, Some(value))
                                            }
                                            Failed => { Matched(pos, None) }
                                        };
                                    match seq_res {
                                        Matched(pos, e) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            let mut s = s;
                                                            if let Some(last)
                                                                   = e {
                                                                s.push(ast::Statement::Expression(last));
                                                            }
                                                            s
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_statement<'input>(input: &'input str, state: &mut ParseState,
                           pos: usize) -> RuleResult<ast::Statement> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse___(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_terminated(input, state, pos);
                                match seq_res {
                                    Matched(pos, t) => {
                                        {
                                            let seq_res =
                                                {
                                                    let choice_res =
                                                        {
                                                            let seq_res =
                                                                parse___(input,
                                                                         state,
                                                                         pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    slice_eq(input,
                                                                             state,
                                                                             pos,
                                                                             ";")
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        };
                                                    match choice_res {
                                                        Matched(pos, value) =>
                                                        Matched(pos, value),
                                                        Failed => {
                                                            let seq_res =
                                                                {
                                                                    let mut repeat_pos =
                                                                        pos;
                                                                    loop  {
                                                                        let pos =
                                                                            repeat_pos;
                                                                        let step_res =
                                                                            parse_whitespace(input,
                                                                                             state,
                                                                                             pos);
                                                                        match step_res
                                                                            {
                                                                            Matched(newpos,
                                                                                    value)
                                                                            =>
                                                                            {
                                                                                repeat_pos
                                                                                    =
                                                                                    newpos;
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            {
                                                                                break
                                                                                    ;
                                                                            }
                                                                        }
                                                                    }
                                                                    Matched(repeat_pos,
                                                                            ())
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    parse_newline(input,
                                                                                  state,
                                                                                  pos)
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                };
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos, { t })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse___(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, ";");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    { ast::Statement::Empty })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_terminated<'input>(input: &'input str, state: &mut ParseState,
                            pos: usize) -> RuleResult<ast::Statement> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_declaration(input, state, pos);
                    match seq_res {
                        Matched(pos, d) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos,
                                        { ast::Statement::Declaration(d) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res =
                                slice_eq(input, state, pos, "throw");
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            parse___(input, state, pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        parse_expression(input,
                                                                         state,
                                                                         pos);
                                                    match seq_res {
                                                        Matched(pos, e) => {
                                                            {
                                                                let match_str =
                                                                    &input[start_pos..pos];
                                                                Matched(pos,
                                                                        {
                                                                            ast::Statement::Throw(e)
                                                                        })
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let start_pos = pos;
                        {
                            let seq_res = parse_expression(input, state, pos);
                            match seq_res {
                                Matched(pos, e) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos,
                                                {
                                                    ast::Statement::Expression(e)
                                                })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_declaration<'input>(input: &'input str, state: &mut ParseState,
                             pos: usize) -> RuleResult<ast::Declaration> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "var");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse___(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_identifier(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, id) => {
                                                    {
                                                        let seq_res =
                                                            match {
                                                                      let start_pos =
                                                                          pos;
                                                                      {
                                                                          let seq_res =
                                                                              parse___(input,
                                                                                       state,
                                                                                       pos);
                                                                          match seq_res
                                                                              {
                                                                              Matched(pos,
                                                                                      _)
                                                                              =>
                                                                              {
                                                                                  {
                                                                                      let seq_res =
                                                                                          slice_eq(input,
                                                                                                   state,
                                                                                                   pos,
                                                                                                   "=");
                                                                                      match seq_res
                                                                                          {
                                                                                          Matched(pos,
                                                                                                  _)
                                                                                          =>
                                                                                          {
                                                                                              {
                                                                                                  let seq_res =
                                                                                                      parse___(input,
                                                                                                               state,
                                                                                                               pos);
                                                                                                  match seq_res
                                                                                                      {
                                                                                                      Matched(pos,
                                                                                                              _)
                                                                                                      =>
                                                                                                      {
                                                                                                          {
                                                                                                              let seq_res =
                                                                                                                  parse_expression(input,
                                                                                                                                   state,
                                                                                                                                   pos);
                                                                                                              match seq_res
                                                                                                                  {
                                                                                                                  Matched(pos,
                                                                                                                          e)
                                                                                                                  =>
                                                                                                                  {
                                                                                                                      {
                                                                                                                          let match_str =
                                                                                                                              &input[start_pos..pos];
                                                                                                                          Matched(pos,
                                                                                                                                  {
                                                                                                                                      e
                                                                                                                                  })
                                                                                                                      }
                                                                                                                  }
                                                                                                                  Failed
                                                                                                                  =>
                                                                                                                  Failed,
                                                                                                              }
                                                                                                          }
                                                                                                      }
                                                                                                      Failed
                                                                                                      =>
                                                                                                      Failed,
                                                                                                  }
                                                                                              }
                                                                                          }
                                                                                          Failed
                                                                                          =>
                                                                                          Failed,
                                                                                      }
                                                                                  }
                                                                              }
                                                                              Failed
                                                                              =>
                                                                              Failed,
                                                                          }
                                                                      }
                                                                  } {
                                                                Matched(newpos,
                                                                        value)
                                                                => {
                                                                    Matched(newpos,
                                                                            Some(value))
                                                                }
                                                                Failed => {
                                                                    Matched(pos,
                                                                            None)
                                                                }
                                                            };
                                                        match seq_res {
                                                            Matched(pos, init)
                                                            => {
                                                                {
                                                                    let match_str =
                                                                        &input[start_pos..pos];
                                                                    Matched(pos,
                                                                            {
                                                                                ast::Declaration::Variable(id,
                                                                                                           init)
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_function_declaration(input, state, pos),
        }
    }
}
fn parse_expression<'input>(input: &'input str, state: &mut ParseState,
                            pos: usize) -> RuleResult<ast::Expression> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_product(input, state, pos);
            match seq_res {
                Matched(pos, l) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_sum_op(input,
                                                                             state,
                                                                             pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        op) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse___(input,
                                                                                     state,
                                                                                     pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_product(input,
                                                                                                      state,
                                                                                                      pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                r)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    &input[start_pos..pos];
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            (op,
                                                                                                             r)
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                let mut expr = l;
                                                for (op, right) in s {
                                                    expr =
                                                        ast::Expression::Binary(op,
                                                                                Box::new(expr),
                                                                                Box::new(right))
                                                }
                                                expr
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_product<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> RuleResult<ast::Expression> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_simple_expression(input, state, pos);
            match seq_res {
                Matched(pos, l) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_product_op(input,
                                                                                 state,
                                                                                 pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        op) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse___(input,
                                                                                     state,
                                                                                     pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_simple_expression(input,
                                                                                                                state,
                                                                                                                pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                r)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    &input[start_pos..pos];
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            (op,
                                                                                                             r)
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                let mut expr = l;
                                                for (op, right) in s {
                                                    expr =
                                                        ast::Expression::Binary(op,
                                                                                Box::new(expr),
                                                                                Box::new(right));
                                                }
                                                expr
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_simple_expression<'input>(input: &'input str, state: &mut ParseState,
                                   pos: usize)
 -> RuleResult<ast::Expression> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_literal(input, state, pos);
                    match seq_res {
                        Matched(pos, v) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { ast::Expression::Literal(v) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res =
                                parse_function_literal(input, state, pos);
                            match seq_res {
                                Matched(pos, f) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos,
                                                {
                                                    ast::Expression::Function(f)
                                                })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_access(input, state, pos);
                                    match seq_res {
                                        Matched(pos, lhs) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "=");
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse___(input,
                                                                                     state,
                                                                                     pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_expression(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                rhs)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    &input[start_pos..pos];
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            ast::Expression::Assignment(lhs,
                                                                                                                                        Box::new(rhs))
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_method_call(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_atomic_expression(input,
                                                                    state,
                                                                    pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let start_pos = pos;
                                                {
                                                    let seq_res =
                                                        parse_unary_op(input,
                                                                       state,
                                                                       pos);
                                                    match seq_res {
                                                        Matched(pos, op) => {
                                                            {
                                                                let seq_res =
                                                                    parse___(input,
                                                                             state,
                                                                             pos);
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let seq_res =
                                                                                parse_simple_expression(input,
                                                                                                        state,
                                                                                                        pos);
                                                                            match seq_res
                                                                                {
                                                                                Matched(pos,
                                                                                        exp)
                                                                                =>
                                                                                {
                                                                                    {
                                                                                        let match_str =
                                                                                            &input[start_pos..pos];
                                                                                        Matched(pos,
                                                                                                {
                                                                                                    ast::Expression::Unary(op,
                                                                                                                           Box::new(exp))
                                                                                                })
                                                                                    }
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                Failed,
                                                                            }
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_unary_op<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> RuleResult<ast::UnaryOp> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "+");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { ast::UnaryOp::Positive })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "-");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { ast::UnaryOp::Negative })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_sum_op<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> RuleResult<ast::BinaryOp> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "+");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { ast::BinaryOp::Add })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "-");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { ast::BinaryOp::Subtract })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_product_op<'input>(input: &'input str, state: &mut ParseState,
                            pos: usize) -> RuleResult<ast::BinaryOp> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "*");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { ast::BinaryOp::Multiply })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "/");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { ast::BinaryOp::Divide })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_method_call<'input>(input: &'input str, state: &mut ParseState,
                             pos: usize) -> RuleResult<ast::Expression> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_access(input, state, pos);
            match seq_res {
                Matched(pos, f) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_called(input, state, pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, calls) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                let mut func =
                                                    ast::Expression::Access(f);
                                                for el in calls {
                                                    func =
                                                        ast::Expression::Call(Box::new(func),
                                                                              el)
                                                }
                                                func
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_access<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> RuleResult<ast::Access> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_atomic_expression(input, state, pos);
                    match seq_res {
                        Matched(pos, p) => {
                            {
                                let seq_res =
                                    {
                                        let mut repeat_pos = pos;
                                        let mut repeat_value = vec!();
                                        loop  {
                                            let pos = repeat_pos;
                                            let step_res =
                                                parse_call_access(input,
                                                                  state, pos);
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                    repeat_value.push(value);
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        if repeat_value.len() >= 1usize {
                                            Matched(repeat_pos, repeat_value)
                                        } else { Failed }
                                    };
                                match seq_res {
                                    Matched(pos, c) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    {
                                                        let mut iter =
                                                            c.into_iter();
                                                        let (first_calls,
                                                             first_id) =
                                                            iter.next().unwrap();
                                                        let mut expr = p;
                                                        for call in
                                                            first_calls {
                                                            expr =
                                                                ast::Expression::Call(Box::new(expr),
                                                                                      call)
                                                        }
                                                        let mut ret =
                                                            ast::Access::Member(Box::new(expr),
                                                                                first_id);
                                                        for (calls, id) in
                                                            iter {
                                                            let mut expr =
                                                                ast::Expression::Access(ret);
                                                            for call in calls
                                                                {
                                                                expr =
                                                                    ast::Expression::Call(Box::new(expr),
                                                                                          call)
                                                            }
                                                            ret =
                                                                ast::Access::Member(Box::new(expr),
                                                                                    id)
                                                        }
                                                        ret
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { ast::Access::Identifier(i) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_call_access<'input>(input: &'input str, state: &mut ParseState,
                             pos: usize)
 -> RuleResult<(Vec<ast::ExpressionList>, ast::Identifier)> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res = parse_called(input, state, pos);
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, repeat_value)
                };
            match seq_res {
                Matched(pos, c) => {
                    {
                        let seq_res = parse_dotted(input, state, pos);
                        match seq_res {
                            Matched(pos, d) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { (c, d) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_dotted<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> RuleResult<ast::Identifier> {
    {
        let start_pos = pos;
        {
            let seq_res = parse___(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = slice_eq(input, state, pos, ".");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res = parse___(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_identifier(input,
                                                                     state,
                                                                     pos);
                                                match seq_res {
                                                    Matched(pos, i) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    { i })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_called<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> RuleResult<ast::ExpressionList> {
    {
        let start_pos = pos;
        {
            let seq_res = parse___(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = slice_eq(input, state, pos, "(");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res = parse___(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_expression_list(input,
                                                                          state,
                                                                          pos);
                                                match seq_res {
                                                    Matched(pos, el) => {
                                                        {
                                                            let seq_res =
                                                                parse___(input,
                                                                         state,
                                                                         pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            slice_eq(input,
                                                                                     state,
                                                                                     pos,
                                                                                     ")");
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        &input[start_pos..pos];
                                                                                    Matched(pos,
                                                                                            {
                                                                                                el
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_atomic_expression<'input>(input: &'input str, state: &mut ParseState,
                                   pos: usize)
 -> RuleResult<ast::Expression> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "this");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { ast::Expression::This })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_literal(input, state, pos);
                            match seq_res {
                                Matched(pos, v) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos,
                                                {
                                                    ast::Expression::Literal(v)
                                                })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_function_literal(input, state,
                                                               pos);
                                    match seq_res {
                                        Matched(pos, f) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            ast::Expression::Function(f)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_identifier(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, i) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    ast::Expression::Access(ast::Access::Identifier(i))
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "(");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse___(input,
                                                                     state,
                                                                     pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_expression(input,
                                                                                         state,
                                                                                         pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                e)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse___(input,
                                                                                             state,
                                                                                             pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                slice_eq(input,
                                                                                                         state,
                                                                                                         pos,
                                                                                                         ")");
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let match_str =
                                                                                                            &input[start_pos..pos];
                                                                                                        Matched(pos,
                                                                                                                {
                                                                                                                    e
                                                                                                                })
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_expression_list<'input>(input: &'input str, state: &mut ParseState,
                                 pos: usize)
 -> RuleResult<ast::ExpressionList> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let pos =
                if repeat_value.len() > 0 {
                    let sep_res = slice_eq(input, state, pos, ",");
                    match sep_res {
                        Matched(newpos, _) => { newpos }
                        Failed => break ,
                    }
                } else { pos };
            let step_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_expression(input, state, pos);
                                    match seq_res {
                                        Matched(pos, e) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    { e })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                };
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, repeat_value)
    }
}
fn parse_literal<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> RuleResult<interpret::Value> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_number(input, state, pos);
                    match seq_res {
                        Matched(pos, n) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { interpret::Value::Number(n) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_string(input, state, pos);
                            match seq_res {
                                Matched(pos, s) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos,
                                                {
                                                    interpret::Value::String(s)
                                                })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "null");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            interpret::Value::Object(interpret::Object::Null)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos,
                                                 "undefined");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            interpret::Value::Undefined
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_function_literal<'input>(input: &'input str, state: &mut ParseState,
                                  pos: usize)
 -> RuleResult<interpret::UserFunction> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "function");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        match parse_identifier(input, state,
                                                               pos) {
                                            Matched(newpos, value) => {
                                                Matched(newpos, Some(value))
                                            }
                                            Failed => { Matched(pos, None) }
                                        };
                                    match seq_res {
                                        Matched(pos, i) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "(");
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_parameters(input,
                                                                                             state,
                                                                                             pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    p)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        slice_eq(input,
                                                                                                 state,
                                                                                                 pos,
                                                                                                 ")");
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse___(input,
                                                                                                             state,
                                                                                                             pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let seq_res =
                                                                                                                slice_eq(input,
                                                                                                                         state,
                                                                                                                         pos,
                                                                                                                         "{");
                                                                                                            match seq_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        _)
                                                                                                                =>
                                                                                                                {
                                                                                                                    {
                                                                                                                        let seq_res =
                                                                                                                            parse_block(input,
                                                                                                                                        state,
                                                                                                                                        pos);
                                                                                                                        match seq_res
                                                                                                                            {
                                                                                                                            Matched(pos,
                                                                                                                                    b)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                {
                                                                                                                                    let seq_res =
                                                                                                                                        slice_eq(input,
                                                                                                                                                 state,
                                                                                                                                                 pos,
                                                                                                                                                 "}");
                                                                                                                                    match seq_res
                                                                                                                                        {
                                                                                                                                        Matched(pos,
                                                                                                                                                _)
                                                                                                                                        =>
                                                                                                                                        {
                                                                                                                                            {
                                                                                                                                                let match_str =
                                                                                                                                                    &input[start_pos..pos];
                                                                                                                                                Matched(pos,
                                                                                                                                                        {
                                                                                                                                                            interpret::UserFunction{id:
                                                                                                                                                                                        i,
                                                                                                                                                                                    parameters:
                                                                                                                                                                                        p,
                                                                                                                                                                                    body:
                                                                                                                                                                                        b,
                                                                                                                                                                                    source:
                                                                                                                                                                                        match_str.to_string(),}
                                                                                                                                                        })
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        Failed
                                                                                                                                        =>
                                                                                                                                        Failed,
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                            Failed
                                                                                                                            =>
                                                                                                                            Failed,
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                Failed
                                                                                                                =>
                                                                                                                Failed,
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_function_declaration<'input>(input: &'input str,
                                      state: &mut ParseState, pos: usize)
 -> RuleResult<ast::Declaration> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "function");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_identifier(input, state, pos);
                                    match seq_res {
                                        Matched(pos, i) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "(");
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_parameters(input,
                                                                                             state,
                                                                                             pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    p)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        slice_eq(input,
                                                                                                 state,
                                                                                                 pos,
                                                                                                 ")");
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse___(input,
                                                                                                             state,
                                                                                                             pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let seq_res =
                                                                                                                slice_eq(input,
                                                                                                                         state,
                                                                                                                         pos,
                                                                                                                         "{");
                                                                                                            match seq_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        _)
                                                                                                                =>
                                                                                                                {
                                                                                                                    {
                                                                                                                        let seq_res =
                                                                                                                            parse_block(input,
                                                                                                                                        state,
                                                                                                                                        pos);
                                                                                                                        match seq_res
                                                                                                                            {
                                                                                                                            Matched(pos,
                                                                                                                                    b)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                {
                                                                                                                                    let seq_res =
                                                                                                                                        slice_eq(input,
                                                                                                                                                 state,
                                                                                                                                                 pos,
                                                                                                                                                 "}");
                                                                                                                                    match seq_res
                                                                                                                                        {
                                                                                                                                        Matched(pos,
                                                                                                                                                _)
                                                                                                                                        =>
                                                                                                                                        {
                                                                                                                                            {
                                                                                                                                                let match_str =
                                                                                                                                                    &input[start_pos..pos];
                                                                                                                                                Matched(pos,
                                                                                                                                                        {
                                                                                                                                                            ast::Declaration::Function(i.clone(),
                                                                                                                                                                                       interpret::UserFunction{id:
                                                                                                                                                                                                                   Some(i),
                                                                                                                                                                                                               parameters:
                                                                                                                                                                                                                   p,
                                                                                                                                                                                                               body:
                                                                                                                                                                                                                   b,
                                                                                                                                                                                                               source:
                                                                                                                                                                                                                   match_str.to_string(),})
                                                                                                                                                        })
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        Failed
                                                                                                                                        =>
                                                                                                                                        Failed,
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                            Failed
                                                                                                                            =>
                                                                                                                            Failed,
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                Failed
                                                                                                                =>
                                                                                                                Failed,
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_parameters<'input>(input: &'input str, state: &mut ParseState,
                            pos: usize) -> RuleResult<Vec<ast::Identifier>> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let pos =
                if repeat_value.len() > 0 {
                    let sep_res = slice_eq(input, state, pos, ",");
                    match sep_res {
                        Matched(newpos, _) => { newpos }
                        Failed => break ,
                    }
                } else { pos };
            let step_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_identifier(input, state, pos);
                                    match seq_res {
                                        Matched(pos, p) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    { p })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                };
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, repeat_value)
    }
}
fn parse___<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> RuleResult<()> {
    {
        let mut repeat_pos = pos;
        loop  {
            let pos = repeat_pos;
            let step_res =
                {
                    let choice_res = parse_whitespace(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_newline(input, state, pos),
                    }
                };
            match step_res {
                Matched(newpos, value) => { repeat_pos = newpos; }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, ())
    }
}
fn parse_whitespace<'input>(input: &'input str, state: &mut ParseState,
                            pos: usize) -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            ' ' | '\t' => Matched(next, ()),
            _ => state.mark_failure(pos, "[ \t]"),
        }
    } else { state.mark_failure(pos, "[ \t]") }
}
fn parse_newline<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            '\n' | '\r' => Matched(next, ()),
            _ => state.mark_failure(pos, "[\n\r]"),
        }
    } else { state.mark_failure(pos, "[\n\r]") }
}
fn parse_identifier<'input>(input: &'input str, state: &mut ParseState,
                            pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            if input.len() > pos {
                                let (ch, next) = char_range_at(input, pos);
                                match ch {
                                    'a' ...'z' | 'A' ...'Z' | '_' =>
                                    Matched(next, ()),
                                    _ => state.mark_failure(pos, "[a-zA-Z_]"),
                                }
                            } else { state.mark_failure(pos, "[a-zA-Z_]") };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1usize {
                        Matched(repeat_pos, ())
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { match_str.to_string() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_number<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> RuleResult<f64> {
    {
        let start_pos = pos;
        {
            let seq_res =
                match slice_eq(input, state, pos, "-") {
                    Matched(newpos, value) => { Matched(newpos, Some(value)) }
                    Failed => { Matched(pos, None) }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let choice_res =
                                    parse_frac(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let seq_res =
                                            {
                                                let mut repeat_pos = pos;
                                                let mut repeat_value = vec!();
                                                loop  {
                                                    let pos = repeat_pos;
                                                    let step_res =
                                                        if input.len() > pos {
                                                            let (ch, next) =
                                                                char_range_at(input,
                                                                              pos);
                                                            match ch {
                                                                '0' ...'9' =>
                                                                Matched(next,
                                                                        ()),
                                                                _ =>
                                                                state.mark_failure(pos,
                                                                                   "[0-9]"),
                                                            }
                                                        } else {
                                                            state.mark_failure(pos,
                                                                               "[0-9]")
                                                        };
                                                    match step_res {
                                                        Matched(newpos, value)
                                                        => {
                                                            repeat_pos =
                                                                newpos;
                                                            repeat_value.push(value);
                                                        }
                                                        Failed => { break ; }
                                                    }
                                                }
                                                if repeat_value.len() >=
                                                       1usize {
                                                    Matched(repeat_pos, ())
                                                } else { Failed }
                                            };
                                        match seq_res {
                                            Matched(pos, _) => {
                                                parse_frac_opt(input, state,
                                                               pos)
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        match {
                                                  let seq_res =
                                                      {
                                                          let choice_res =
                                                              slice_eq(input,
                                                                       state,
                                                                       pos,
                                                                       "e");
                                                          match choice_res {
                                                              Matched(pos,
                                                                      value)
                                                              =>
                                                              Matched(pos,
                                                                      value),
                                                              Failed =>
                                                              slice_eq(input,
                                                                       state,
                                                                       pos,
                                                                       "E"),
                                                          }
                                                      };
                                                  match seq_res {
                                                      Matched(pos, _) => {
                                                          {
                                                              let seq_res =
                                                                  match {
                                                                            let choice_res =
                                                                                slice_eq(input,
                                                                                         state,
                                                                                         pos,
                                                                                         "+");
                                                                            match choice_res
                                                                                {
                                                                                Matched(pos,
                                                                                        value)
                                                                                =>
                                                                                Matched(pos,
                                                                                        value),
                                                                                Failed
                                                                                =>
                                                                                slice_eq(input,
                                                                                         state,
                                                                                         pos,
                                                                                         "-"),
                                                                            }
                                                                        } {
                                                                      Matched(newpos,
                                                                              value)
                                                                      => {
                                                                          Matched(newpos,
                                                                                  Some(value))
                                                                      }
                                                                      Failed
                                                                      => {
                                                                          Matched(pos,
                                                                                  None)
                                                                      }
                                                                  };
                                                              match seq_res {
                                                                  Matched(pos,
                                                                          _)
                                                                  => {
                                                                      {
                                                                          let mut repeat_pos =
                                                                              pos;
                                                                          let mut repeat_value =
                                                                              vec!();
                                                                          loop 
                                                                               {
                                                                              let pos =
                                                                                  repeat_pos;
                                                                              let step_res =
                                                                                  if input.len()
                                                                                         >
                                                                                         pos
                                                                                     {
                                                                                      let (ch,
                                                                                           next) =
                                                                                          char_range_at(input,
                                                                                                        pos);
                                                                                      match ch
                                                                                          {
                                                                                          '0'
                                                                                          ...'9'
                                                                                          =>
                                                                                          Matched(next,
                                                                                                  ()),
                                                                                          _
                                                                                          =>
                                                                                          state.mark_failure(pos,
                                                                                                             "[0-9]"),
                                                                                      }
                                                                                  } else {
                                                                                      state.mark_failure(pos,
                                                                                                         "[0-9]")
                                                                                  };
                                                                              match step_res
                                                                                  {
                                                                                  Matched(newpos,
                                                                                          value)
                                                                                  =>
                                                                                  {
                                                                                      repeat_pos
                                                                                          =
                                                                                          newpos;
                                                                                      repeat_value.push(value);
                                                                                  }
                                                                                  Failed
                                                                                  =>
                                                                                  {
                                                                                      break
                                                                                          ;
                                                                                  }
                                                                              }
                                                                          }
                                                                          if repeat_value.len()
                                                                                 >=
                                                                                 1usize
                                                                             {
                                                                              Matched(repeat_pos,
                                                                                      ())
                                                                          } else {
                                                                              Failed
                                                                          }
                                                                      }
                                                                  }
                                                                  Failed =>
                                                                  Failed,
                                                              }
                                                          }
                                                      }
                                                      Failed => Failed,
                                                  }
                                              } {
                                            Matched(newpos, value) => {
                                                Matched(newpos, Some(value))
                                            }
                                            Failed => { Matched(pos, None) }
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            match_str.parse().unwrap()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_frac<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ".");
        match seq_res {
            Matched(pos, _) => {
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            if input.len() > pos {
                                let (ch, next) = char_range_at(input, pos);
                                match ch {
                                    '0' ...'9' => Matched(next, ()),
                                    _ => state.mark_failure(pos, "[0-9]"),
                                }
                            } else { state.mark_failure(pos, "[0-9]") };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1usize {
                        Matched(repeat_pos, ())
                    } else { Failed }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_frac_opt<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> RuleResult<()> {
    {
        let start_pos = pos;
        {
            let seq_res =
                match parse_frac(input, state, pos) {
                    Matched(newpos, value) => { Matched(newpos, Some(value)) }
                    Failed => { Matched(pos, None) }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { () })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_string<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> RuleResult<String> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "\"");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    {
                                        let mut repeat_pos = pos;
                                        let mut repeat_value = vec!();
                                        loop  {
                                            let pos = repeat_pos;
                                            let step_res =
                                                {
                                                    let choice_res =
                                                        parse_escape(input,
                                                                     state,
                                                                     pos);
                                                    match choice_res {
                                                        Matched(pos, value) =>
                                                        Matched(pos, value),
                                                        Failed => {
                                                            let start_pos =
                                                                pos;
                                                            {
                                                                let seq_res =
                                                                    if input.len()
                                                                           >
                                                                           pos
                                                                       {
                                                                        let (ch,
                                                                             next) =
                                                                            char_range_at(input,
                                                                                          pos);
                                                                        match ch
                                                                            {
                                                                            '\"'
                                                                            =>
                                                                            state.mark_failure(pos,
                                                                                               "[^\"]"),
                                                                            _
                                                                            =>
                                                                            Matched(next,
                                                                                    ()),
                                                                        }
                                                                    } else {
                                                                        state.mark_failure(pos,
                                                                                           "[^\"]")
                                                                    };
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let match_str =
                                                                                &input[start_pos..pos];
                                                                            Matched(pos,
                                                                                    {
                                                                                        match_str.chars().next().unwrap()
                                                                                    })
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                    }
                                                };
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                    repeat_value.push(value);
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        if repeat_value.len() >= 1usize {
                                            Matched(repeat_pos, repeat_value)
                                        } else { Failed }
                                    };
                                match seq_res {
                                    Matched(pos, s) => {
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "\"");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    let mut result =
                                                                        String::new();
                                                                    for c in s
                                                                        {
                                                                        result.push(c);
                                                                    }
                                                                    result
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "\'");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    {
                                        let mut repeat_pos = pos;
                                        let mut repeat_value = vec!();
                                        loop  {
                                            let pos = repeat_pos;
                                            let step_res =
                                                {
                                                    let choice_res =
                                                        parse_escape(input,
                                                                     state,
                                                                     pos);
                                                    match choice_res {
                                                        Matched(pos, value) =>
                                                        Matched(pos, value),
                                                        Failed => {
                                                            let start_pos =
                                                                pos;
                                                            {
                                                                let seq_res =
                                                                    if input.len()
                                                                           >
                                                                           pos
                                                                       {
                                                                        let (ch,
                                                                             next) =
                                                                            char_range_at(input,
                                                                                          pos);
                                                                        match ch
                                                                            {
                                                                            '\''
                                                                            =>
                                                                            state.mark_failure(pos,
                                                                                               "[^\']"),
                                                                            _
                                                                            =>
                                                                            Matched(next,
                                                                                    ()),
                                                                        }
                                                                    } else {
                                                                        state.mark_failure(pos,
                                                                                           "[^\']")
                                                                    };
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let match_str =
                                                                                &input[start_pos..pos];
                                                                            Matched(pos,
                                                                                    {
                                                                                        match_str.chars().next().unwrap()
                                                                                    })
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                    }
                                                };
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                    repeat_value.push(value);
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        if repeat_value.len() >= 1usize {
                                            Matched(repeat_pos, repeat_value)
                                        } else { Failed }
                                    };
                                match seq_res {
                                    Matched(pos, s) => {
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "\'");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    let mut result =
                                                                        String::new();
                                                                    for c in s
                                                                        {
                                                                        result.push(c);
                                                                    }
                                                                    result
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_escape<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, c) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                match c {
                                                    'b' => '\u{8}',
                                                    'f' => '\u{c}',
                                                    'n' => '\n',
                                                    'r' => '\r',
                                                    't' => '\t',
                                                    'v' => '\u{b}',
                                                    '0' => '\u{0}',
                                                    _ => c,
                                                }
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_any_char<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = any_char(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { match_str.chars().next().unwrap() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
pub fn parse<'input>(input: &'input str) -> ParseResult<ast::Block> {
    let mut state = ParseState::new();
    match parse_parse(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
