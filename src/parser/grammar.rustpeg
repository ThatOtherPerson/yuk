use super::super::{ast, runtime};

#[pub]
parse -> ast::Block
    = block

block -> ast::Block
    = s:statement* __ e:expression? {
        let mut s = s;
        if let Some(last) = e {
            s.push(ast::Statement::Expression(last));
        }

        s
    }

statement -> ast::Statement
    = __ t:terminated (__ ";" / whitespace* newline) { t }
    / __ ";" { ast::Statement::Empty }

terminated -> ast::Statement
    = d:declaration { ast::Statement::Declaration(d) }
    / e:expression { ast::Statement::Expression(e) }

declaration -> ast::Declaration
    = "var" __ id:identifier init:(__ "=" __ e:expression { e })? { ast::Declaration::Variable(id, init) }
    / function_declaration

expression -> ast::Expression
    = v:literal { ast::Expression::Literal(v) }
    / lhs:access __ "=" __ rhs:expression { ast::Expression::Assignment(lhs, Box::new(rhs)) }
    / method_call
    / atomic_expression

method_call -> ast::Expression
    = f:access calls:called* {
        let mut func = ast::Expression::Access(f);
        for el in calls {
            func = ast::Expression::Call(Box::new(func), el)
        }
        func
    }

access -> ast::Access
    = p:atomic_expression c:call_access+ {
        let mut iter = c.into_iter();
        let (first_calls, first_id) = iter.next().unwrap();
        let mut expr = p;
        for call in first_calls {
            expr = ast::Expression::Call(Box::new(expr), call)
        }
        let mut ret = ast::Access::Member(Box::new(expr), first_id);

        for (calls, id) in iter {
            let mut expr = ast::Expression::Access(ret);
            for call in calls {
                expr = ast::Expression::Call(Box::new(expr), call)
            }
            ret = ast::Access::Member(Box::new(expr), id)
        }

        ret
    }
    / i:identifier { ast::Access::Identifier(i) }

call_access -> (Vec<ast::ExpressionList>, ast::Identifier)
    = c:called* d:dotted { (c, d) }

dotted -> ast::Identifier
    = __ "." __ i:identifier { i }

called -> ast::ExpressionList
    = __ "(" __ el:expression_list __ ")" { el }

atomic_expression -> ast::Expression
    = v:literal { ast::Expression::Literal(v) }
    / i:identifier { ast::Expression::Access(ast::Access::Identifier(i)) }
    / "(" __ e:expression __ ")" { e }

expression_list -> ast::ExpressionList
    = (__ e:expression __ {e}) ** ","

literal -> runtime::Value
    = n:number { runtime::Value::Number(n) }
    / f:function_literal { runtime::Value::Function(f) }
    / s:string { runtime::Value::String(s) }
    / "null" { runtime::Value::Object(runtime::Object::Null) }
    / "undefined" { runtime::Value::Undefined }

function_literal -> runtime::Function
    = "function" __ i:identifier? __ "(" p:parameters ")" __ "{" b:block "}" {
        runtime::Function::User {id: i, parameters: p, body: b, source: match_str.to_string()}
    }

function_declaration -> ast::Declaration
    = "function" __ i:identifier __ "(" p:parameters ")" __ "{" b:block "}" {
        ast::Declaration::Function(
            i.clone(),
            runtime::Function::User {id: Some(i), parameters: p, body: b, source: match_str.to_string()}
        )
    }

parameters -> Vec<ast::Identifier>
    = (__ p:identifier __ { p }) ** ","

__ = (whitespace / newline)*

whitespace
    = [ \t]

newline
    = [\n\r]

identifier -> String
    = [a-zA-Z_]+ { match_str.to_string() }

number -> f64
    // TODO: get rid of "-"? - once we have unary expressions it won't be necessary
    = "-"? (frac / [0-9]+ frac_opt) (("e" / "E") ("+" / "-")? [0-9]+)? { match_str.parse().unwrap() }

frac
    = "." [0-9]+

frac_opt
    = frac? { () }

string -> String
    = "\"" s:(escape / [^"] { match_str.chars().next().unwrap() })+ "\"" {
        let mut result = String::new();
        for c in s {
            result.push(c);
        }
        result
    }

escape -> char
    = "\\" c:any_char {
        match c {
            'b' => '\x08',
            'f' => '\x0c',
            'n' => '\x0a',
            'r' => '\x0d',
            't' => '\x09',
            'v' => '\x0b',
            '0' => '\0',
            _ => c
        }
    }

any_char -> char
    = . { match_str.chars().next().unwrap() }
