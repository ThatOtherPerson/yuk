use super::super::{ast, runtime};

#[pub]
parse -> ast::Block
    = s:statement* __ { s }

statement -> ast::Statement
    = e:expression (__ ";" / whitespace* newline) { ast::Statement::Expression(e) }
    / __ ";" { ast::Statement::Empty }

expression -> ast::Expression
    = __ o:method_call accesses:dotted {
        let mut ret = o;
        for e in accesses {
            ret = ast::Expression::Member(Box::new(ret), e)
        }
        ret
    }
    / method_call

method_call -> ast::Expression
    = access:member_access calls:(__ "(" el:expression_list __ ")" { el } )* {
        let mut ret = access;
        for e in calls {
            ret = ast::Expression::Call(Box::new(ret), e)
        }
        ret
    }

member_access -> ast::Expression
    = o:atomic_expression accesses:dotted {
        let mut ret = o;
        for e in accesses {
            ret = ast::Expression::Member(Box::new(ret), e)
        }
        ret
    }

dotted -> Vec<ast::Identifier>
    = (__ "." __ i:identifier { i })*

atomic_expression -> ast::Expression
    = i:identifier { ast::Expression::Identifier(i) }
    / "(" __ e:expression __ ")" { e }
    / v:literal { ast::Expression::Literal(v) }

expression_list -> ast::ExpressionList
    = (e:expression {e}) ** ","

literal -> runtime::Value
    = i:integer { runtime::Value::Number(i) }

__ = (whitespace / newline)*

whitespace
    = [ \t]

newline
    = [\n\r]

identifier -> String
    = [a-zA-Z_]+ { match_str.to_string() }

// TODO: number, not integer
integer -> f64
    = [0-9]+ { match_str.parse().unwrap() }
