use super::super::{ast, runtime};

#[pub]
parse -> ast::Block
    = s:statement* __ { s }

statement -> ast::Statement
    = e:expression (__ ";" / whitespace* newline) { ast::Statement::Expression(e) }
    / __ ";" { ast::Statement::Empty }

expression -> ast::Expression
    = lhs:access __ "=" __ rhs:expression { ast::Expression::Assignment(lhs, Box::new(rhs)) }
    / method_call
    / atomic_expression

method_call -> ast::Expression
    = f:access calls:called* {
        let mut func = ast::Expression::Access(f);
        for el in calls {
            func = ast::Expression::Call(Box::new(func), el)
        }
        func
    }

access -> ast::Access
    = p:atomic_expression c:call_access+ {
        let mut iter = c.into_iter();
        let (first_calls, first_id) = iter.next().unwrap();
        let mut expr = p;
        for call in first_calls {
            expr = ast::Expression::Call(Box::new(expr), call)
        }
        let mut ret = ast::Access::Member(Box::new(expr), first_id);

        for (calls, id) in iter {
            let mut expr = ast::Expression::Access(ret);
            for call in calls {
                expr = ast::Expression::Call(Box::new(expr), call)
            }
            ret = ast::Access::Member(Box::new(expr), id)
        }

        ret
    }
    / i:identifier { ast::Access::Identifier(i) }

call_access -> (Vec<ast::ExpressionList>, ast::Identifier)
    = c:called* d:dotted { (c, d) }

dotted -> ast::Identifier
    = __ "." __ i:identifier { i }

called -> ast::ExpressionList
    = __ "(" __ el:expression_list __ ")" { el }

atomic_expression -> ast::Expression
    = i:identifier { ast::Expression::Access(ast::Access::Identifier(i)) }
    / "(" __ e:expression __ ")" { e }
    / __ v:literal { ast::Expression::Literal(v) }

expression_list -> ast::ExpressionList
    = (e:expression {e}) ** ","

literal -> runtime::Value
    = i:integer { runtime::Value::Number(i) }

__ = (whitespace / newline)*

whitespace
    = [ \t]

newline
    = [\n\r]

identifier -> String
    = [a-zA-Z_]+ { match_str.to_string() }

// TODO: number, not integer
integer -> f64
    = [0-9]+ { match_str.parse().unwrap() }
